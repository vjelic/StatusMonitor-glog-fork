{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "a37b6771-6293-3880-9999-ce1db2d7a9c0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behaviors. This is a common vulnerability in C and C++ programming, often referred to as \"Detected Vulnerability in C Function (strlen)\".\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen`, which takes an additional parameter to specify the maximum length of the string. This can prevent buffer overflows by ensuring that `strnlen` does not read past the end of the buffer.\n\n## Source Code Fix Recommendation\n\nReplace the `strlen` function with `strnlen` and specify a maximum length for the string. For example:\n\n```cpp\nsize_t max_length = sizeof(C_KernelString) / sizeof(C_KernelString[0]) - 1;\nC_KernelString_size[] = { strnlen(C_KernelString, max_length) };\n```\n\nThis code will prevent `strnlen` from reading past the end of the `C_KernelString` buffer, mitigating the vulnerability.\n\n## Library Dependencies\n\nThe code example requires the `cstring` library to execute properly.\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-126)](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "2337f332-7c68-3c2d-8449-32a6f8caa524",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable random numbers. This can be exploited by attackers to predict the outcome of the program's operations that rely on these random numbers, leading to potential security breaches.\n\nThe `RAND_MAX` is a constant defined in the C++ standard library. It represents the maximum value that can be returned by the `rand()` function. The `rand()` function is a weak random number generator and should not be used for generating random numbers in a security context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator instead of weak or non-cryptographic ones. In C++, you can use functions provided by libraries like `<random>` which provides a variety of random number generators that are more secure and less predictable than `rand()`.\n\n## Source Code Fix Recommendation\n\nInstead of using `rand()`, use `std::random_device` and `std::mt19937` from the `<random>` library. Here is an example:\n\n```cpp\n#include <random>\n\nstd::random_device rd;  // Will be used to obtain a seed for the random number engine\nstd::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\nstd::uniform_int_distribution<> distrib(1, 6);\n\nint random_number = distrib(gen);\n```\n\n## Library Dependencies\n\nThe above code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "2337f332-7c68-3c2d-8449-32a6f8caa524"
                ]
              }
            },
            {
              "id": "6caefda1-77d3-3b05-80e6-cfb6c6f53c18",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the use of non-cryptographic or weak random number generators can lead to vulnerabilities. The `rand()` function, for example, is a weak random number generator because it is predictable and can be easily reproduced. This can lead to security issues, especially when used in security-sensitive contexts such as generating passwords, cryptographic keys, or any other security parameters.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong, cryptographic random number generator. In C++, this can be achieved by using functions provided by libraries such as `<random>` or `<cryptopp>`.\n\n## Source Code Fix Recommendation\n\nInstead of using `rand()`, you can use `std::random_device` from the `<random>` library to generate a truly random number. Here is an example:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;\n    int random_number = rd();\n    // Use random_number\n    return 0;\n}\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\n\n## Library Dependencies\n\nThe above code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "6caefda1-77d3-3b05-80e6-cfb6c6f53c18"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "a37b6771-6293-3880-9999-ce1db2d7a9c0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/HealthTest.cpp"
                },
                "region": {
                  "startLine": 681,
                  "startColumn": 40,
                  "endLine": 681,
                  "endColumn": 62,
                  "charOffset": 20658,
                  "charLength": 22,
                  "snippet": {
                    "text": "strlen(C_KernelString)",
                    "rendered": {
                      "text": "strlen(C_KernelString)",
                      "markdown": "`strlen(C_KernelString)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/HealthTest.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 20658,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strlen_s(C_KernelString, <size of C_KernelString>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/HealthTest.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 20658,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strnlen(C_KernelString, <size of C_KernelString>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}